var content=(function(){"use strict";function ae(o){return o}var j=Object.prototype.hasOwnProperty;function N(o,e){var t,r;if(o===e)return!0;if(o&&e&&(t=o.constructor)===e.constructor){if(t===Date)return o.getTime()===e.getTime();if(t===RegExp)return o.toString()===e.toString();if(t===Array){if((r=o.length)===e.length)for(;r--&&N(o[r],e[r]););return r===-1}if(!t||typeof o=="object"){r=0;for(t in o)if(j.call(o,t)&&++r&&!j.call(e,t)||!(t in e)||!N(o[t],e[t]))return!1;return Object.keys(e).length===r}}return o!==o&&e!==e}const Y=new Error("request for lock canceled");var Q=function(o,e,t,r){function l(u){return u instanceof t?u:new t(function(h){h(u)})}return new(t||(t=Promise))(function(u,h){function m(v){try{w(r.next(v))}catch(E){h(E)}}function I(v){try{w(r.throw(v))}catch(E){h(E)}}function w(v){v.done?u(v.value):l(v.value).then(m,I)}w((r=r.apply(o,e||[])).next())})};class B{constructor(e,t=Y){this._value=e,this._cancelError=t,this._queue=[],this._weightedWaiters=[]}acquire(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise((r,l)=>{const u={resolve:r,reject:l,weight:e,priority:t},h=U(this._queue,m=>t<=m.priority);h===-1&&e<=this._value?this._dispatchItem(u):this._queue.splice(h+1,0,u)})}runExclusive(e){return Q(this,arguments,void 0,function*(t,r=1,l=0){const[u,h]=yield this.acquire(r,l);try{return yield t(u)}finally{h()}})}waitForUnlock(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,t)?Promise.resolve():new Promise(r=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),z(this._weightedWaiters[e-1],{resolve:r,priority:t})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach(e=>e.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const t=this._value;this._value-=e.weight,e.resolve([t,this._newReleaser(e.weight)])}_newReleaser(e){let t=!1;return()=>{t||(t=!0,this.release(e))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let e=this._value;e>0;e--){const t=this._weightedWaiters[e-1];t&&(t.forEach(r=>r.resolve()),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let t=this._value;t>0;t--){const r=this._weightedWaiters[t-1];if(!r)continue;const l=r.findIndex(u=>u.priority<=e);(l===-1?r:r.splice(0,l)).forEach((u=>u.resolve()))}}}_couldLockImmediately(e,t){return(this._queue.length===0||this._queue[0].priority<t)&&e<=this._value}}function z(o,e){const t=U(o,r=>e.priority<=r.priority);o.splice(t+1,0,e)}function U(o,e){for(let t=o.length-1;t>=0;t--)if(e(o[t]))return t;return-1}var H=function(o,e,t,r){function l(u){return u instanceof t?u:new t(function(h){h(u)})}return new(t||(t=Promise))(function(u,h){function m(v){try{w(r.next(v))}catch(E){h(E)}}function I(v){try{w(r.throw(v))}catch(E){h(E)}}function w(v){v.done?u(v.value):l(v.value).then(m,I)}w((r=r.apply(o,e||[])).next())})};class J{constructor(e){this._semaphore=new B(1,e)}acquire(){return H(this,arguments,void 0,function*(e=0){const[,t]=yield this._semaphore.acquire(1,e);return t})}runExclusive(e,t=0){return this._semaphore.runExclusive(()=>e(),1,t)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}const k=globalThis.browser?.runtime?.id?globalThis.browser:globalThis.chrome,W=X();function X(){const o={local:K("local"),session:K("session"),sync:K("sync"),managed:K("managed")},e=s=>{const a=o[s];if(a==null){const n=Object.keys(o).join(", ");throw Error(`Invalid area "${s}". Options: ${n}`)}return a},t=s=>{const a=s.indexOf(":"),n=s.substring(0,a),i=s.substring(a+1);if(i==null)throw Error(`Storage key should be in the form of "area:key", but received "${s}"`);return{driverArea:n,driverKey:i,driver:e(n)}},r=s=>s+"$",l=(s,a)=>{const n={...s};return Object.entries(a).forEach(([i,c])=>{c==null?delete n[i]:n[i]=c}),n},u=(s,a)=>s??a??null,h=s=>typeof s=="object"&&!Array.isArray(s)?s:{},m=async(s,a,n)=>{const i=await s.getItem(a);return u(i,n?.fallback??n?.defaultValue)},I=async(s,a)=>{const n=r(a),i=await s.getItem(n);return h(i)},w=async(s,a,n)=>{await s.setItem(a,n??null)},v=async(s,a,n)=>{const i=r(a),c=h(await s.getItem(i));await s.setItem(i,l(c,n))},E=async(s,a,n)=>{if(await s.removeItem(a),n?.removeMeta){const i=r(a);await s.removeItem(i)}},b=async(s,a,n)=>{const i=r(a);if(n==null)await s.removeItem(i);else{const c=h(await s.getItem(i));[n].flat().forEach(d=>delete c[d]),await s.setItem(i,c)}},x=(s,a,n)=>s.watch(a,n);return{getItem:async(s,a)=>{const{driver:n,driverKey:i}=t(s);return await m(n,i,a)},getItems:async s=>{const a=new Map,n=new Map,i=[];s.forEach(d=>{let f,g;typeof d=="string"?f=d:"getValue"in d?(f=d.key,g={fallback:d.fallback}):(f=d.key,g=d.options),i.push(f);const{driverArea:_,driverKey:p}=t(f),S=a.get(_)??[];a.set(_,S.concat(p)),n.set(f,g)});const c=new Map;return await Promise.all(Array.from(a.entries()).map(async([d,f])=>{(await o[d].getItems(f)).forEach(_=>{const p=`${d}:${_.key}`,S=n.get(p),M=u(_.value,S?.fallback??S?.defaultValue);c.set(p,M)})})),i.map(d=>({key:d,value:c.get(d)}))},getMeta:async s=>{const{driver:a,driverKey:n}=t(s);return await I(a,n)},getMetas:async s=>{const a=s.map(c=>{const d=typeof c=="string"?c:c.key,{driverArea:f,driverKey:g}=t(d);return{key:d,driverArea:f,driverKey:g,driverMetaKey:r(g)}}),n=a.reduce((c,d)=>(c[d.driverArea]??=[],c[d.driverArea].push(d),c),{}),i={};return await Promise.all(Object.entries(n).map(async([c,d])=>{const f=await k.storage[c].get(d.map(g=>g.driverMetaKey));d.forEach(g=>{i[g.key]=f[g.driverMetaKey]??{}})})),a.map(c=>({key:c.key,meta:i[c.key]}))},setItem:async(s,a)=>{const{driver:n,driverKey:i}=t(s);await w(n,i,a)},setItems:async s=>{const a={};s.forEach(n=>{const{driverArea:i,driverKey:c}=t("key"in n?n.key:n.item.key);a[i]??=[],a[i].push({key:c,value:n.value})}),await Promise.all(Object.entries(a).map(async([n,i])=>{await e(n).setItems(i)}))},setMeta:async(s,a)=>{const{driver:n,driverKey:i}=t(s);await v(n,i,a)},setMetas:async s=>{const a={};s.forEach(n=>{const{driverArea:i,driverKey:c}=t("key"in n?n.key:n.item.key);a[i]??=[],a[i].push({key:c,properties:n.meta})}),await Promise.all(Object.entries(a).map(async([n,i])=>{const c=e(n),d=i.map(({key:p})=>r(p)),f=await c.getItems(d),g=Object.fromEntries(f.map(({key:p,value:S})=>[p,h(S)])),_=i.map(({key:p,properties:S})=>{const M=r(p);return{key:M,value:l(g[M]??{},S)}});await c.setItems(_)}))},removeItem:async(s,a)=>{const{driver:n,driverKey:i}=t(s);await E(n,i,a)},removeItems:async s=>{const a={};s.forEach(n=>{let i,c;typeof n=="string"?i=n:"getValue"in n?i=n.key:"item"in n?(i=n.item.key,c=n.options):(i=n.key,c=n.options);const{driverArea:d,driverKey:f}=t(i);a[d]??=[],a[d].push(f),c?.removeMeta&&a[d].push(r(f))}),await Promise.all(Object.entries(a).map(async([n,i])=>{await e(n).removeItems(i)}))},clear:async s=>{await e(s).clear()},removeMeta:async(s,a)=>{const{driver:n,driverKey:i}=t(s);await b(n,i,a)},snapshot:async(s,a)=>{const i=await e(s).snapshot();return a?.excludeKeys?.forEach(c=>{delete i[c],delete i[r(c)]}),i},restoreSnapshot:async(s,a)=>{await e(s).restoreSnapshot(a)},watch:(s,a)=>{const{driver:n,driverKey:i}=t(s);return x(n,i,a)},unwatch(){Object.values(o).forEach(s=>{s.unwatch()})},defineItem:(s,a)=>{const{driver:n,driverKey:i}=t(s),{version:c=1,migrations:d={},onMigrationComplete:f,debug:g=!1}=a??{};if(c<1)throw Error("Storage item version cannot be less than 1. Initial versions should be set to 1, not 0.");const _=async()=>{const y=r(i),[{value:T},{value:C}]=await n.getItems([i,y]);if(T==null)return;const V=C?.v??1;if(V>c)throw Error(`Version downgrade detected (v${V} -> v${c}) for "${s}"`);if(V===c)return;g===!0&&console.debug(`[@wxt-dev/storage] Running storage migration for ${s}: v${V} -> v${c}`);const se=Array.from({length:c-V},(F,P)=>V+P+1);let $=T;for(const F of se)try{$=await d?.[F]?.($)??$,g===!0&&console.debug(`[@wxt-dev/storage] Storage migration processed for version: v${F}`)}catch(P){throw new Z(s,F,{cause:P})}await n.setItems([{key:i,value:$},{key:y,value:{...C,v:c}}]),g===!0&&console.debug(`[@wxt-dev/storage] Storage migration completed for ${s} v${c}`,{migratedValue:$}),f?.($,c)},p=a?.migrations==null?Promise.resolve():_().catch(y=>{console.error(`[@wxt-dev/storage] Migration failed for ${s}`,y)}),S=new J,M=()=>a?.fallback??a?.defaultValue??null,G=()=>S.runExclusive(async()=>{const y=await n.getItem(i);if(y!=null||a?.init==null)return y;const T=await a.init();return await n.setItem(i,T),T});return p.then(G),{key:s,get defaultValue(){return M()},get fallback(){return M()},getValue:async()=>(await p,a?.init?await G():await m(n,i,a)),getMeta:async()=>(await p,await I(n,i)),setValue:async y=>(await p,await w(n,i,y)),setMeta:async y=>(await p,await v(n,i,y)),removeValue:async y=>(await p,await E(n,i,y)),removeMeta:async y=>(await p,await b(n,i,y)),watch:y=>x(n,i,(T,C)=>y(T??M(),C??M())),migrate:_}}}}function K(o){const e=()=>{if(k.runtime==null)throw Error(["'wxt/storage' must be loaded in a web extension environment",`
 - If thrown during a build, see https://github.com/wxt-dev/wxt/issues/371`,` - If thrown during tests, mock 'wxt/browser' correctly. See https://wxt.dev/guide/go-further/testing.html
`].join(`
`));if(k.storage==null)throw Error("You must add the 'storage' permission to your manifest to use 'wxt/storage'");const r=k.storage[o];if(r==null)throw Error(`"browser.storage.${o}" is undefined`);return r},t=new Set;return{getItem:async r=>(await e().get(r))[r],getItems:async r=>{const l=await e().get(r);return r.map(u=>({key:u,value:l[u]??null}))},setItem:async(r,l)=>{l==null?await e().remove(r):await e().set({[r]:l})},setItems:async r=>{const l=r.reduce((u,{key:h,value:m})=>(u[h]=m,u),{});await e().set(l)},removeItem:async r=>{await e().remove(r)},removeItems:async r=>{await e().remove(r)},clear:async()=>{await e().clear()},snapshot:async()=>await e().get(),restoreSnapshot:async r=>{await e().set(r)},watch(r,l){const u=h=>{const m=h[r];m!=null&&(N(m.newValue,m.oldValue)||l(m.newValue??null,m.oldValue??null))};return e().onChanged.addListener(u),t.add(u),()=>{e().onChanged.removeListener(u),t.delete(u)}},unwatch(){t.forEach(r=>{e().onChanged.removeListener(r)}),t.clear()}}}class Z extends Error{constructor(e,t,r){super(`v${t} migration failed for "${e}"`,r),this.key=e,this.version=t}}const ee={matches:["*://*.facebook.com/*"],async main(){console.log("FB Reels Speed Extension Loaded");let o=await W.getItem("local:speed")||1;const e={childList:!0,subtree:!0},t=l=>{if(l.parentElement?.querySelector(".fb-speed-controller"))return;l.playbackRate=o;const u=()=>{o&&Math.abs(l.playbackRate-o)>.1&&(l.playbackRate=o)};l.addEventListener("ratechange",u),l.addEventListener("play",u),l.addEventListener("loadedmetadata",u);const h=document.createElement("div");h.className="fb-speed-controller";const m=document.createElement("div");m.className="fb-speed-icon",m.innerText=`${o}x`;const I=document.createElement("div");I.className="fb-speed-slider-container";const w=document.createElement("input");w.type="range",w.className="fb-speed-slider",w.min="0.5",w.max="4.0",w.step="0.25",w.value=o.toString(),w.addEventListener("input",b=>{const x=parseFloat(b.target.value);o=x,l.playbackRate=x,m.innerText=`${x}x`,W.setItem("local:speed",x)});const v=b=>{b.stopPropagation(),b.stopImmediatePropagation()};["click","mousedown","mouseup","dblclick","pointerdown","pointerup","touchstart","touchend"].forEach(b=>{h.addEventListener(b,v)}),I.appendChild(w),h.appendChild(m),h.appendChild(I);const E=l.parentElement;E&&(window.getComputedStyle(E).position==="static"&&(E.style.position="relative"),E.appendChild(h))};new MutationObserver(l=>{for(const u of l)u.type==="childList"&&document.querySelectorAll("video").forEach(t)}).observe(document.body,e),document.querySelectorAll("video").forEach(t)}},D=k;function L(o,...e){}const te={debug:(...o)=>L(console.debug,...o),log:(...o)=>L(console.log,...o),warn:(...o)=>L(console.warn,...o),error:(...o)=>L(console.error,...o)};class R extends Event{constructor(e,t){super(R.EVENT_NAME,{}),this.newUrl=e,this.oldUrl=t}static EVENT_NAME=O("wxt:locationchange")}function O(o){return`${D?.runtime?.id}:content:${o}`}function re(o){let e,t;return{run(){e==null&&(t=new URL(location.href),e=o.setInterval(()=>{let r=new URL(location.href);r.href!==t.href&&(window.dispatchEvent(new R(r,t)),t=r)},1e3))}}}class q{constructor(e,t){this.contentScriptName=e,this.options=t,this.abortController=new AbortController,this.isTopFrame?(this.listenForNewerScripts({ignoreFirstEvent:!0}),this.stopOldScripts()):this.listenForNewerScripts()}static SCRIPT_STARTED_MESSAGE_TYPE=O("wxt:content-script-started");isTopFrame=window.self===window.top;abortController;locationWatcher=re(this);receivedMessageIds=new Set;get signal(){return this.abortController.signal}abort(e){return this.abortController.abort(e)}get isInvalid(){return D.runtime.id==null&&this.notifyInvalidated(),this.signal.aborted}get isValid(){return!this.isInvalid}onInvalidated(e){return this.signal.addEventListener("abort",e),()=>this.signal.removeEventListener("abort",e)}block(){return new Promise(()=>{})}setInterval(e,t){const r=setInterval(()=>{this.isValid&&e()},t);return this.onInvalidated(()=>clearInterval(r)),r}setTimeout(e,t){const r=setTimeout(()=>{this.isValid&&e()},t);return this.onInvalidated(()=>clearTimeout(r)),r}requestAnimationFrame(e){const t=requestAnimationFrame((...r)=>{this.isValid&&e(...r)});return this.onInvalidated(()=>cancelAnimationFrame(t)),t}requestIdleCallback(e,t){const r=requestIdleCallback((...l)=>{this.signal.aborted||e(...l)},t);return this.onInvalidated(()=>cancelIdleCallback(r)),r}addEventListener(e,t,r,l){t==="wxt:locationchange"&&this.isValid&&this.locationWatcher.run(),e.addEventListener?.(t.startsWith("wxt:")?O(t):t,r,{...l,signal:this.signal})}notifyInvalidated(){this.abort("Content script context invalidated"),te.debug(`Content script "${this.contentScriptName}" context invalidated`)}stopOldScripts(){window.postMessage({type:q.SCRIPT_STARTED_MESSAGE_TYPE,contentScriptName:this.contentScriptName,messageId:Math.random().toString(36).slice(2)},"*")}verifyScriptStartedEvent(e){const t=e.data?.type===q.SCRIPT_STARTED_MESSAGE_TYPE,r=e.data?.contentScriptName===this.contentScriptName,l=!this.receivedMessageIds.has(e.data?.messageId);return t&&r&&l}listenForNewerScripts(e){let t=!0;const r=l=>{if(this.verifyScriptStartedEvent(l)){this.receivedMessageIds.add(l.data.messageId);const u=t;if(t=!1,u&&e?.ignoreFirstEvent)return;this.notifyInvalidated()}};addEventListener("message",r),this.onInvalidated(()=>removeEventListener("message",r))}}function ie(){}function A(o,...e){}const ne={debug:(...o)=>A(console.debug,...o),log:(...o)=>A(console.log,...o),warn:(...o)=>A(console.warn,...o),error:(...o)=>A(console.error,...o)};return(async()=>{try{const{main:o,...e}=ee,t=new q("content",e);return await o(t)}catch(o){throw ne.error('The content script "content" crashed on startup!',o),o}})()})();
content;